// Generated by zig-wayland

const server = @import("wayland.zig").server;
const common = @import("common.zig");pub const PointerGesturesV1 = opaque {
 pub const generated_version = 3;
 pub const interface = &common.zwp.pointer_gestures_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*PointerGesturesV1 {
    return @ptrCast(try server.wl.Resource.create(_client, PointerGesturesV1, _version, _id));
}pub fn destroy(_pointer_gestures_v1: *PointerGesturesV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *PointerGesturesV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_pointer_gestures_v1: *PointerGesturesV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).getLink();
}pub fn getClient(_pointer_gestures_v1: *PointerGesturesV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).getClient();
}pub fn getId(_pointer_gestures_v1: *PointerGesturesV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).getId();
}pub fn getVersion(_pointer_gestures_v1: *PointerGesturesV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).getVersion();
}pub fn postNoMemory(_pointer_gestures_v1: *PointerGesturesV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).postNoMemory();
}pub fn getUserData(_pointer_gestures_v1: *PointerGesturesV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gestures_v1)).getUserData();
}pub const Request = union(enum) {get_swipe_gesture: struct {id:u32,pointer:*server.wl.Pointer,},
get_pinch_gesture: struct {id:u32,pointer:*server.wl.Pointer,},
release: void,get_hold_gesture: struct {id:u32,pointer:*server.wl.Pointer,},
};
pub inline fn setHandler(
    _pointer_gestures_v1: *PointerGesturesV1,
    comptime T: type,
    handle_request: *const fn (_pointer_gestures_v1: *PointerGesturesV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_pointer_gestures_v1: *PointerGesturesV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_pointer_gestures_v1);
    _resource.setDispatcher(
        common.Dispatcher(PointerGesturesV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*PointerGesturesV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}};
pub const PointerGestureSwipeV1 = opaque {
 pub const generated_version = 2;
 pub const interface = &common.zwp.pointer_gesture_swipe_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*PointerGestureSwipeV1 {
    return @ptrCast(try server.wl.Resource.create(_client, PointerGestureSwipeV1, _version, _id));
}pub fn destroy(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *PointerGestureSwipeV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).getLink();
}pub fn getClient(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).getClient();
}pub fn getId(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).getId();
}pub fn getVersion(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).getVersion();
}pub fn postNoMemory(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).postNoMemory();
}pub fn getUserData(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_swipe_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,};
pub inline fn setHandler(
    _pointer_gesture_swipe_v1: *PointerGestureSwipeV1,
    comptime T: type,
    handle_request: *const fn (_pointer_gesture_swipe_v1: *PointerGestureSwipeV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_pointer_gesture_swipe_v1: *PointerGestureSwipeV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_swipe_v1);
    _resource.setDispatcher(
        common.Dispatcher(PointerGestureSwipeV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*PointerGestureSwipeV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendBegin(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1, _serial:u32, _time:u32, _surface:*server.wl.Surface, _fingers:u32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_swipe_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .o = @ptrCast(_surface) },.{ .u = _fingers},};
_resource.postEvent(0, &_args);}
pub fn sendUpdate(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1, _time:u32, _dx:common.Fixed, _dy:common.Fixed) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_swipe_v1);var _args = [_]common.Argument{.{ .u = _time},.{ .f = _dx},.{ .f = _dy},};
_resource.postEvent(1, &_args);}
pub fn sendEnd(_pointer_gesture_swipe_v1: *PointerGestureSwipeV1, _serial:u32, _time:u32, _cancelled:i32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_swipe_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .i = _cancelled},};
_resource.postEvent(2, &_args);}
};
pub const PointerGesturePinchV1 = opaque {
 pub const generated_version = 2;
 pub const interface = &common.zwp.pointer_gesture_pinch_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*PointerGesturePinchV1 {
    return @ptrCast(try server.wl.Resource.create(_client, PointerGesturePinchV1, _version, _id));
}pub fn destroy(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *PointerGesturePinchV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).getLink();
}pub fn getClient(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).getClient();
}pub fn getId(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).getId();
}pub fn getVersion(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).getVersion();
}pub fn postNoMemory(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).postNoMemory();
}pub fn getUserData(_pointer_gesture_pinch_v1: *PointerGesturePinchV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_pinch_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,};
pub inline fn setHandler(
    _pointer_gesture_pinch_v1: *PointerGesturePinchV1,
    comptime T: type,
    handle_request: *const fn (_pointer_gesture_pinch_v1: *PointerGesturePinchV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_pointer_gesture_pinch_v1: *PointerGesturePinchV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_pinch_v1);
    _resource.setDispatcher(
        common.Dispatcher(PointerGesturePinchV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*PointerGesturePinchV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendBegin(_pointer_gesture_pinch_v1: *PointerGesturePinchV1, _serial:u32, _time:u32, _surface:*server.wl.Surface, _fingers:u32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_pinch_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .o = @ptrCast(_surface) },.{ .u = _fingers},};
_resource.postEvent(0, &_args);}
pub fn sendUpdate(_pointer_gesture_pinch_v1: *PointerGesturePinchV1, _time:u32, _dx:common.Fixed, _dy:common.Fixed, _scale:common.Fixed, _rotation:common.Fixed) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_pinch_v1);var _args = [_]common.Argument{.{ .u = _time},.{ .f = _dx},.{ .f = _dy},.{ .f = _scale},.{ .f = _rotation},};
_resource.postEvent(1, &_args);}
pub fn sendEnd(_pointer_gesture_pinch_v1: *PointerGesturePinchV1, _serial:u32, _time:u32, _cancelled:i32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_pinch_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .i = _cancelled},};
_resource.postEvent(2, &_args);}
};
pub const PointerGestureHoldV1 = opaque {
 pub const generated_version = 3;
 pub const interface = &common.zwp.pointer_gesture_hold_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*PointerGestureHoldV1 {
    return @ptrCast(try server.wl.Resource.create(_client, PointerGestureHoldV1, _version, _id));
}pub fn destroy(_pointer_gesture_hold_v1: *PointerGestureHoldV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *PointerGestureHoldV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_pointer_gesture_hold_v1: *PointerGestureHoldV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).getLink();
}pub fn getClient(_pointer_gesture_hold_v1: *PointerGestureHoldV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).getClient();
}pub fn getId(_pointer_gesture_hold_v1: *PointerGestureHoldV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).getId();
}pub fn getVersion(_pointer_gesture_hold_v1: *PointerGestureHoldV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).getVersion();
}pub fn postNoMemory(_pointer_gesture_hold_v1: *PointerGestureHoldV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).postNoMemory();
}pub fn getUserData(_pointer_gesture_hold_v1: *PointerGestureHoldV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_pointer_gesture_hold_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,};
pub inline fn setHandler(
    _pointer_gesture_hold_v1: *PointerGestureHoldV1,
    comptime T: type,
    handle_request: *const fn (_pointer_gesture_hold_v1: *PointerGestureHoldV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_pointer_gesture_hold_v1: *PointerGestureHoldV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_hold_v1);
    _resource.setDispatcher(
        common.Dispatcher(PointerGestureHoldV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*PointerGestureHoldV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendBegin(_pointer_gesture_hold_v1: *PointerGestureHoldV1, _serial:u32, _time:u32, _surface:*server.wl.Surface, _fingers:u32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_hold_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .o = @ptrCast(_surface) },.{ .u = _fingers},};
_resource.postEvent(0, &_args);}
pub fn sendEnd(_pointer_gesture_hold_v1: *PointerGestureHoldV1, _serial:u32, _time:u32, _cancelled:i32) void {const _resource: *server.wl.Resource = @ptrCast(_pointer_gesture_hold_v1);var _args = [_]common.Argument{.{ .u = _serial},.{ .u = _time},.{ .i = _cancelled},};
_resource.postEvent(1, &_args);}
};
