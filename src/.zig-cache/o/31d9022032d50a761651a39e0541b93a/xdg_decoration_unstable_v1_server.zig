// Generated by zig-wayland

// Copyright Â© 2018 Simon Ser
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

const server = @import("wayland.zig").server;
const common = @import("common.zig");pub const DecorationManagerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zxdg.decoration_manager_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*DecorationManagerV1 {
    return @ptrCast(try server.wl.Resource.create(_client, DecorationManagerV1, _version, _id));
}pub fn destroy(_decoration_manager_v1: *DecorationManagerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *DecorationManagerV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_decoration_manager_v1: *DecorationManagerV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).getLink();
}pub fn getClient(_decoration_manager_v1: *DecorationManagerV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).getClient();
}pub fn getId(_decoration_manager_v1: *DecorationManagerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).getId();
}pub fn getVersion(_decoration_manager_v1: *DecorationManagerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).getVersion();
}pub fn postNoMemory(_decoration_manager_v1: *DecorationManagerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).postNoMemory();
}pub fn getUserData(_decoration_manager_v1: *DecorationManagerV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_decoration_manager_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,get_toplevel_decoration: struct {id:u32,toplevel:*server.xdg.Toplevel,},
};
pub inline fn setHandler(
    _decoration_manager_v1: *DecorationManagerV1,
    comptime T: type,
    handle_request: *const fn (_decoration_manager_v1: *DecorationManagerV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_decoration_manager_v1: *DecorationManagerV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_decoration_manager_v1);
    _resource.setDispatcher(
        common.Dispatcher(DecorationManagerV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*DecorationManagerV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}};
pub const ToplevelDecorationV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zxdg.toplevel_decoration_v1.interface;pub const Error = common.zxdg.toplevel_decoration_v1.Error;
pub const Mode = common.zxdg.toplevel_decoration_v1.Mode;
pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*ToplevelDecorationV1 {
    return @ptrCast(try server.wl.Resource.create(_client, ToplevelDecorationV1, _version, _id));
}pub fn destroy(_toplevel_decoration_v1: *ToplevelDecorationV1) void {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *ToplevelDecorationV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_toplevel_decoration_v1: *ToplevelDecorationV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).getLink();
}pub fn getClient(_toplevel_decoration_v1: *ToplevelDecorationV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).getClient();
}pub fn getId(_toplevel_decoration_v1: *ToplevelDecorationV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).getId();
}pub fn getVersion(_toplevel_decoration_v1: *ToplevelDecorationV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).getVersion();
}pub fn postNoMemory(_toplevel_decoration_v1: *ToplevelDecorationV1) void {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).postNoMemory();
}pub fn getUserData(_toplevel_decoration_v1: *ToplevelDecorationV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_toplevel_decoration_v1)).getUserData();
}pub fn postError(toplevel_decoration_v1: *ToplevelDecorationV1, _err: Error, _message: [*:0]const u8) void {
    return @as(*server.wl.Resource, @ptrCast(toplevel_decoration_v1)).postError(@intCast(@intFromEnum(_err)), _message);
}pub const Request = union(enum) {destroy: void,set_mode: struct {mode:Mode,},
unset_mode: void,};
pub inline fn setHandler(
    _toplevel_decoration_v1: *ToplevelDecorationV1,
    comptime T: type,
    handle_request: *const fn (_toplevel_decoration_v1: *ToplevelDecorationV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_toplevel_decoration_v1: *ToplevelDecorationV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_toplevel_decoration_v1);
    _resource.setDispatcher(
        common.Dispatcher(ToplevelDecorationV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*ToplevelDecorationV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendConfigure(_toplevel_decoration_v1: *ToplevelDecorationV1, _mode:Mode) void {const _resource: *server.wl.Resource = @ptrCast(_toplevel_decoration_v1);var _args = [_]common.Argument{.{ .u = switch (@typeInfo(Mode )) {
    .Enum => @as(u32, @intCast(@intFromEnum(_mode))),
    .Struct => @bitCast(_mode),
    else => unreachable,
 }},};
_resource.postEvent(0, &_args);}
};
