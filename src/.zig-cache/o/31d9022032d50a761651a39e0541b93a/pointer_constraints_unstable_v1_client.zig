// Generated by zig-wayland

// Copyright © 2014      Jonas Ådahl
// Copyright © 2015      Red Hat Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

// This protocol specifies a set of interfaces used for adding constraints to
// the motion of a pointer. Possible constraints include confining pointer
// motions to a given region, or locking it to its current position.
// 
// In order to constrain the pointer, a client must first bind the global
// interface "wp_pointer_constraints" which, if a compositor supports pointer
// constraints, is exposed by the registry. Using the bound global object, the
// client uses the request that corresponds to the type of constraint it wants
// to make. See wp_pointer_constraints for more details.
// 
// Warning! The protocol described in this file is experimental and backward
// incompatible changes may be made. Backward compatible changes may be added
// together with the corresponding interface version bump. Backward
// incompatible changes are done by bumping the version number in the protocol
// and interface names and resetting the interface version. Once the protocol
// is to be declared stable, the 'z' prefix and the version number in the
// protocol and interface names are removed and the interface version number is
// reset.
// 

const std = @import("std");
const posix = std.posix;
const client = @import("wayland.zig").client;
const common = @import("common.zig");pub const PointerConstraintsV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.pointer_constraints_v1.interface;pub const Error = common.zwp.pointer_constraints_v1.Error;
pub const Lifetime = common.zwp.pointer_constraints_v1.Lifetime;
pub fn setQueue(_pointer_constraints_v1: *PointerConstraintsV1, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_pointer_constraints_v1);
    _proxy.setQueue(_queue);
}pub fn destroy(_pointer_constraints_v1: *PointerConstraintsV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_pointer_constraints_v1);_proxy.marshal(0, null);_proxy.destroy();}
pub fn lockPointer(_pointer_constraints_v1: *PointerConstraintsV1, _surface:*client.wl.Surface, _pointer:*client.wl.Pointer, _region:?*client.wl.Region, _lifetime:Lifetime) !*client.zwp.LockedPointerV1{const _proxy: *client.wl.Proxy = @ptrCast(_pointer_constraints_v1);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(_surface) },.{ .o = @ptrCast(_pointer) },.{ .o = @ptrCast(_region) },.{ .u = switch (@typeInfo(Lifetime )) {
    .Enum => @as(u32, @intCast(@intFromEnum(_lifetime))),
    .Struct => @bitCast(_lifetime),
    else => unreachable,
 }},};
return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.zwp.LockedPointerV1.interface));}
pub fn confinePointer(_pointer_constraints_v1: *PointerConstraintsV1, _surface:*client.wl.Surface, _pointer:*client.wl.Pointer, _region:?*client.wl.Region, _lifetime:Lifetime) !*client.zwp.ConfinedPointerV1{const _proxy: *client.wl.Proxy = @ptrCast(_pointer_constraints_v1);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(_surface) },.{ .o = @ptrCast(_pointer) },.{ .o = @ptrCast(_region) },.{ .u = switch (@typeInfo(Lifetime )) {
    .Enum => @as(u32, @intCast(@intFromEnum(_lifetime))),
    .Struct => @bitCast(_lifetime),
    else => unreachable,
 }},};
return @ptrCast(try _proxy.marshalConstructor(2, &_args, client.zwp.ConfinedPointerV1.interface));}
};
pub const LockedPointerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.locked_pointer_v1.interface;pub fn setQueue(_locked_pointer_v1: *LockedPointerV1, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_locked_pointer_v1);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {locked: void,unlocked: void,};
pub inline fn setListener(
    _locked_pointer_v1: *LockedPointerV1,
    comptime T: type,
    _listener: *const fn (locked_pointer_v1: *LockedPointerV1, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_locked_pointer_v1);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(LockedPointerV1, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_locked_pointer_v1: *LockedPointerV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_locked_pointer_v1);_proxy.marshal(0, null);_proxy.destroy();}
pub fn setCursorPositionHint(_locked_pointer_v1: *LockedPointerV1, _surface_x:common.Fixed, _surface_y:common.Fixed) void {const _proxy: *client.wl.Proxy = @ptrCast(_locked_pointer_v1);var _args = [_]common.Argument{.{ .f = _surface_x},.{ .f = _surface_y},};
_proxy.marshal(1, &_args);}
pub fn setRegion(_locked_pointer_v1: *LockedPointerV1, _region:?*client.wl.Region) void {const _proxy: *client.wl.Proxy = @ptrCast(_locked_pointer_v1);var _args = [_]common.Argument{.{ .o = @ptrCast(_region) },};
_proxy.marshal(2, &_args);}
};
pub const ConfinedPointerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.confined_pointer_v1.interface;pub fn setQueue(_confined_pointer_v1: *ConfinedPointerV1, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_confined_pointer_v1);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {confined: void,unconfined: void,};
pub inline fn setListener(
    _confined_pointer_v1: *ConfinedPointerV1,
    comptime T: type,
    _listener: *const fn (confined_pointer_v1: *ConfinedPointerV1, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_confined_pointer_v1);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(ConfinedPointerV1, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_confined_pointer_v1: *ConfinedPointerV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_confined_pointer_v1);_proxy.marshal(0, null);_proxy.destroy();}
pub fn setRegion(_confined_pointer_v1: *ConfinedPointerV1, _region:?*client.wl.Region) void {const _proxy: *client.wl.Proxy = @ptrCast(_confined_pointer_v1);var _args = [_]common.Argument{.{ .o = @ptrCast(_region) },};
_proxy.marshal(1, &_args);}
};
