// Generated by zig-wayland

// Copyright © 2014      Jonas Ådahl
// Copyright © 2015      Red Hat Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

// This protocol specifies a set of interfaces used for adding constraints to
// the motion of a pointer. Possible constraints include confining pointer
// motions to a given region, or locking it to its current position.
// 
// In order to constrain the pointer, a client must first bind the global
// interface "wp_pointer_constraints" which, if a compositor supports pointer
// constraints, is exposed by the registry. Using the bound global object, the
// client uses the request that corresponds to the type of constraint it wants
// to make. See wp_pointer_constraints for more details.
// 
// Warning! The protocol described in this file is experimental and backward
// incompatible changes may be made. Backward compatible changes may be added
// together with the corresponding interface version bump. Backward
// incompatible changes are done by bumping the version number in the protocol
// and interface names and resetting the interface version. Once the protocol
// is to be declared stable, the 'z' prefix and the version number in the
// protocol and interface names are removed and the interface version number is
// reset.
// 

const server = @import("wayland.zig").server;
const common = @import("common.zig");pub const PointerConstraintsV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.pointer_constraints_v1.interface;pub const Error = common.zwp.pointer_constraints_v1.Error;
pub const Lifetime = common.zwp.pointer_constraints_v1.Lifetime;
pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*PointerConstraintsV1 {
    return @ptrCast(try server.wl.Resource.create(_client, PointerConstraintsV1, _version, _id));
}pub fn destroy(_pointer_constraints_v1: *PointerConstraintsV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *PointerConstraintsV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_pointer_constraints_v1: *PointerConstraintsV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).getLink();
}pub fn getClient(_pointer_constraints_v1: *PointerConstraintsV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).getClient();
}pub fn getId(_pointer_constraints_v1: *PointerConstraintsV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).getId();
}pub fn getVersion(_pointer_constraints_v1: *PointerConstraintsV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).getVersion();
}pub fn postNoMemory(_pointer_constraints_v1: *PointerConstraintsV1) void {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).postNoMemory();
}pub fn getUserData(_pointer_constraints_v1: *PointerConstraintsV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_pointer_constraints_v1)).getUserData();
}pub fn postError(pointer_constraints_v1: *PointerConstraintsV1, _err: Error, _message: [*:0]const u8) void {
    return @as(*server.wl.Resource, @ptrCast(pointer_constraints_v1)).postError(@intCast(@intFromEnum(_err)), _message);
}pub const Request = union(enum) {destroy: void,lock_pointer: struct {id:u32,surface:*server.wl.Surface,pointer:*server.wl.Pointer,region:?*server.wl.Region,lifetime:Lifetime,},
confine_pointer: struct {id:u32,surface:*server.wl.Surface,pointer:*server.wl.Pointer,region:?*server.wl.Region,lifetime:Lifetime,},
};
pub inline fn setHandler(
    _pointer_constraints_v1: *PointerConstraintsV1,
    comptime T: type,
    handle_request: *const fn (_pointer_constraints_v1: *PointerConstraintsV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_pointer_constraints_v1: *PointerConstraintsV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_pointer_constraints_v1);
    _resource.setDispatcher(
        common.Dispatcher(PointerConstraintsV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*PointerConstraintsV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}};
pub const LockedPointerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.locked_pointer_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*LockedPointerV1 {
    return @ptrCast(try server.wl.Resource.create(_client, LockedPointerV1, _version, _id));
}pub fn destroy(_locked_pointer_v1: *LockedPointerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *LockedPointerV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_locked_pointer_v1: *LockedPointerV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).getLink();
}pub fn getClient(_locked_pointer_v1: *LockedPointerV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).getClient();
}pub fn getId(_locked_pointer_v1: *LockedPointerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).getId();
}pub fn getVersion(_locked_pointer_v1: *LockedPointerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).getVersion();
}pub fn postNoMemory(_locked_pointer_v1: *LockedPointerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).postNoMemory();
}pub fn getUserData(_locked_pointer_v1: *LockedPointerV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_locked_pointer_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,set_cursor_position_hint: struct {surface_x:common.Fixed,surface_y:common.Fixed,},
set_region: struct {region:?*server.wl.Region,},
};
pub inline fn setHandler(
    _locked_pointer_v1: *LockedPointerV1,
    comptime T: type,
    handle_request: *const fn (_locked_pointer_v1: *LockedPointerV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_locked_pointer_v1: *LockedPointerV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_locked_pointer_v1);
    _resource.setDispatcher(
        common.Dispatcher(LockedPointerV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*LockedPointerV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendLocked(_locked_pointer_v1: *LockedPointerV1) void {const _resource: *server.wl.Resource = @ptrCast(_locked_pointer_v1);_resource.postEvent(0, null);}
pub fn sendUnlocked(_locked_pointer_v1: *LockedPointerV1) void {const _resource: *server.wl.Resource = @ptrCast(_locked_pointer_v1);_resource.postEvent(1, null);}
};
pub const ConfinedPointerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.confined_pointer_v1.interface;pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*ConfinedPointerV1 {
    return @ptrCast(try server.wl.Resource.create(_client, ConfinedPointerV1, _version, _id));
}pub fn destroy(_confined_pointer_v1: *ConfinedPointerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).destroy();
}pub fn fromLink(_link: *server.wl.list.Link) *ConfinedPointerV1 {
    return @ptrCast(server.wl.Resource.fromLink(_link));
}pub fn getLink(_confined_pointer_v1: *ConfinedPointerV1) *server.wl.list.Link {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).getLink();
}pub fn getClient(_confined_pointer_v1: *ConfinedPointerV1) *server.wl.Client {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).getClient();
}pub fn getId(_confined_pointer_v1: *ConfinedPointerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).getId();
}pub fn getVersion(_confined_pointer_v1: *ConfinedPointerV1) u32 {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).getVersion();
}pub fn postNoMemory(_confined_pointer_v1: *ConfinedPointerV1) void {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).postNoMemory();
}pub fn getUserData(_confined_pointer_v1: *ConfinedPointerV1) ?*anyopaque {
    return @as(*server.wl.Resource, @ptrCast(_confined_pointer_v1)).getUserData();
}pub const Request = union(enum) {destroy: void,set_region: struct {region:?*server.wl.Region,},
};
pub inline fn setHandler(
    _confined_pointer_v1: *ConfinedPointerV1,
    comptime T: type,
    handle_request: *const fn (_confined_pointer_v1: *ConfinedPointerV1, request: Request, data: T) void,
    comptime handle_destroy: ?fn (_confined_pointer_v1: *ConfinedPointerV1, data: T) void,
    _data: T,
) void {
    const _resource: *server.wl.Resource = @ptrCast(_confined_pointer_v1);
    _resource.setDispatcher(
        common.Dispatcher(ConfinedPointerV1, T).dispatcher,
        handle_request,
        @ptrFromInt(@intFromPtr(_data)),
        if (handle_destroy) |_handler| struct {
            fn _wrapper(__resource: *server.wl.Resource) callconv(.C) void {
                @call(.always_inline, _handler, .{
                    @as(*ConfinedPointerV1, @ptrCast(__resource)),
                    @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                });
            }
        }._wrapper else null,
    );
}pub fn sendConfined(_confined_pointer_v1: *ConfinedPointerV1) void {const _resource: *server.wl.Resource = @ptrCast(_confined_pointer_v1);_resource.postEvent(0, null);}
pub fn sendUnconfined(_confined_pointer_v1: *ConfinedPointerV1) void {const _resource: *server.wl.Resource = @ptrCast(_confined_pointer_v1);_resource.postEvent(1, null);}
};
