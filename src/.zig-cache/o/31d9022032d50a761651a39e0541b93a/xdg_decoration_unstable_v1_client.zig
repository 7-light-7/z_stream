// Generated by zig-wayland

// Copyright Â© 2018 Simon Ser
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

const std = @import("std");
const posix = std.posix;
const client = @import("wayland.zig").client;
const common = @import("common.zig");pub const DecorationManagerV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zxdg.decoration_manager_v1.interface;pub fn setQueue(_decoration_manager_v1: *DecorationManagerV1, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_decoration_manager_v1);
    _proxy.setQueue(_queue);
}pub fn destroy(_decoration_manager_v1: *DecorationManagerV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_decoration_manager_v1);_proxy.marshal(0, null);_proxy.destroy();}
pub fn getToplevelDecoration(_decoration_manager_v1: *DecorationManagerV1, _toplevel:*client.xdg.Toplevel) !*client.zxdg.ToplevelDecorationV1{const _proxy: *client.wl.Proxy = @ptrCast(_decoration_manager_v1);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(_toplevel) },};
return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.zxdg.ToplevelDecorationV1.interface));}
};
pub const ToplevelDecorationV1 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zxdg.toplevel_decoration_v1.interface;pub const Error = common.zxdg.toplevel_decoration_v1.Error;
pub const Mode = common.zxdg.toplevel_decoration_v1.Mode;
pub fn setQueue(_toplevel_decoration_v1: *ToplevelDecorationV1, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_toplevel_decoration_v1);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {configure: struct {mode:Mode,},
};
pub inline fn setListener(
    _toplevel_decoration_v1: *ToplevelDecorationV1,
    comptime T: type,
    _listener: *const fn (toplevel_decoration_v1: *ToplevelDecorationV1, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_toplevel_decoration_v1);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(ToplevelDecorationV1, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_toplevel_decoration_v1: *ToplevelDecorationV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_toplevel_decoration_v1);_proxy.marshal(0, null);_proxy.destroy();}
pub fn setMode(_toplevel_decoration_v1: *ToplevelDecorationV1, _mode:Mode) void {const _proxy: *client.wl.Proxy = @ptrCast(_toplevel_decoration_v1);var _args = [_]common.Argument{.{ .u = switch (@typeInfo(Mode )) {
    .Enum => @as(u32, @intCast(@intFromEnum(_mode))),
    .Struct => @bitCast(_mode),
    else => unreachable,
 }},};
_proxy.marshal(1, &_args);}
pub fn unsetMode(_toplevel_decoration_v1: *ToplevelDecorationV1) void {const _proxy: *client.wl.Proxy = @ptrCast(_toplevel_decoration_v1);_proxy.marshal(2, null);}
};
