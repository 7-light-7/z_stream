// Generated by zig-wayland

// Copyright 2014 © Stephen "Lyude" Chandler Paul
// Copyright 2015-2024 © Red Hat, Inc.
// 
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the
// next paragraph) shall be included in all copies or substantial
// portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 

// This description provides a high-level overview of the interplay between
// the interfaces defined this protocol. For details, see the protocol
// specification.
// 
// More than one tablet may exist, and device-specifics matter. Tablets are
// not represented by a single virtual device like wl_pointer. A client
// binds to the tablet manager object which is just a proxy object. From
// that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
// and that returns the actual interface that has all the tablets. With
// this indirection, we can avoid merging wp_tablet into the actual Wayland
// protocol, a long-term benefit.
// 
// The wp_tablet_seat sends a "tablet added" event for each tablet
// connected. That event is followed by descriptive events about the
// hardware; currently that includes events for name, vid/pid and
// a wp_tablet.path event that describes a local path. This path can be
// used to uniquely identify a tablet or get more information through
// libwacom. Emulated or nested tablets can skip any of those, e.g. a
// virtual tablet may not have a vid/pid. The sequence of descriptive
// events is terminated by a wp_tablet.done event to signal that a client
// may now finalize any initialization for that tablet.
// 
// Events from tablets require a tool in proximity. Tools are also managed
// by the tablet seat; a "tool added" event is sent whenever a tool is new
// to the compositor. That event is followed by a number of descriptive
// events about the hardware; currently that includes capabilities,
// hardware id and serial number, and tool type. Similar to the tablet
// interface, a wp_tablet_tool.done event is sent to terminate that initial
// sequence.
// 
// Any event from a tool happens on the wp_tablet_tool interface. When the
// tool gets into proximity of the tablet, a proximity_in event is sent on
// the wp_tablet_tool interface, listing the tablet and the surface. That
// event is followed by a motion event with the coordinates. After that,
// it's the usual motion, axis, button, etc. events. The protocol's
// serialisation means events are grouped by wp_tablet_tool.frame events.
// 
// Two special events (that don't exist in X) are down and up. They signal
// "tip touching the surface". For tablets without real proximity
// detection, the sequence is: proximity_in, motion, down, frame.
// 
// When the tool leaves proximity, a proximity_out event is sent. If any
// button is still down, a button release event is sent before this
// proximity event. These button events are sent in the same frame as the
// proximity event to signal to the client that the buttons were held when
// the tool left proximity.
// 
// If the tool moves out of the surface but stays in proximity (i.e.
// between windows), compositor-specific grab policies apply. This usually
// means that the proximity-out is delayed until all buttons are released.
// 
// Moving a tool physically from one tablet to the other has no real effect
// on the protocol, since we already have the tool object from the "tool
// added" event. All the information is already there and the proximity
// events on both tablets are all a client needs to reconstruct what
// happened.
// 
// Some extra axes are normalized, i.e. the client knows the range as
// specified in the protocol (e.g. [0, 65535]), the granularity however is
// unknown. The current normalized axes are pressure, distance, and slider.
// 
// Other extra axes are in physical units as specified in the protocol.
// The current extra axes with physical units are tilt, rotation and
// wheel rotation.
// 
// Since tablets work independently of the pointer controlled by the mouse,
// the focus handling is independent too and controlled by proximity.
// The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
// This cursor surface may be the same as the mouse cursor, and it may be
// the same across tools but it is possible to be more fine-grained. For
// example, a client may set different cursors for the pen and eraser.
// 
// Tools are generally independent of tablets and it is
// compositor-specific policy when a tool can be removed. Common approaches
// will likely include some form of removing a tool when all tablets the
// tool was used on are removed.
// 

const std = @import("std");
const posix = std.posix;
const client = @import("wayland.zig").client;
const common = @import("common.zig");pub const TabletManagerV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_manager_v2.interface;pub fn setQueue(_tablet_manager_v2: *TabletManagerV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_manager_v2);
    _proxy.setQueue(_queue);
}pub fn getTabletSeat(_tablet_manager_v2: *TabletManagerV2, _seat:*client.wl.Seat) !*client.zwp.TabletSeatV2{const _proxy: *client.wl.Proxy = @ptrCast(_tablet_manager_v2);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(_seat) },};
return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.zwp.TabletSeatV2.interface));}
pub fn destroy(_tablet_manager_v2: *TabletManagerV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_manager_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
pub const TabletSeatV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_seat_v2.interface;pub fn setQueue(_tablet_seat_v2: *TabletSeatV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_seat_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {tablet_added: struct {id: *client.zwp.TabletV2,},
tool_added: struct {id: *client.zwp.TabletToolV2,},
pad_added: struct {id: *client.zwp.TabletPadV2,},
};
pub inline fn setListener(
    _tablet_seat_v2: *TabletSeatV2,
    comptime T: type,
    _listener: *const fn (tablet_seat_v2: *TabletSeatV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_seat_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletSeatV2, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_tablet_seat_v2: *TabletSeatV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_seat_v2);_proxy.marshal(0, null);_proxy.destroy();}
};
pub const TabletV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_v2.interface;pub fn setQueue(_tablet_v2: *TabletV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {name: struct {name:[*:0]const u8,},
id: struct {vid:u32,pid:u32,},
path: struct {path:[*:0]const u8,},
done: void,removed: void,};
pub inline fn setListener(
    _tablet_v2: *TabletV2,
    comptime T: type,
    _listener: *const fn (tablet_v2: *TabletV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletV2, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_tablet_v2: *TabletV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_v2);_proxy.marshal(0, null);_proxy.destroy();}
};
pub const TabletToolV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_tool_v2.interface;pub const Type = common.zwp.tablet_tool_v2.Type;
pub const Capability = common.zwp.tablet_tool_v2.Capability;
pub const ButtonState = common.zwp.tablet_tool_v2.ButtonState;
pub const Error = common.zwp.tablet_tool_v2.Error;
pub fn setQueue(_tablet_tool_v2: *TabletToolV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_tool_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {@"type": struct {tool_type:Type,},
hardware_serial: struct {hardware_serial_hi:u32,hardware_serial_lo:u32,},
hardware_id_wacom: struct {hardware_id_hi:u32,hardware_id_lo:u32,},
capability: struct {capability:Capability,},
done: void,removed: void,proximity_in: struct {serial:u32,tablet:?*client.zwp.TabletV2,surface:?*client.wl.Surface,},
proximity_out: void,down: struct {serial:u32,},
up: void,motion: struct {x:common.Fixed,y:common.Fixed,},
pressure: struct {pressure:u32,},
distance: struct {distance:u32,},
tilt: struct {tilt_x:common.Fixed,tilt_y:common.Fixed,},
rotation: struct {degrees:common.Fixed,},
slider: struct {position:i32,},
wheel: struct {degrees:common.Fixed,clicks:i32,},
button: struct {serial:u32,button:u32,state:ButtonState,},
frame: struct {time:u32,},
};
pub inline fn setListener(
    _tablet_tool_v2: *TabletToolV2,
    comptime T: type,
    _listener: *const fn (tablet_tool_v2: *TabletToolV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_tool_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletToolV2, T).dispatcher, _listener, _mut_data);
}pub fn setCursor(_tablet_tool_v2: *TabletToolV2, _serial:u32, _surface:?*client.wl.Surface, _hotspot_x:i32, _hotspot_y:i32) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_tool_v2);var _args = [_]common.Argument{.{ .u = _serial},.{ .o = @ptrCast(_surface) },.{ .i = _hotspot_x},.{ .i = _hotspot_y},};
_proxy.marshal(0, &_args);}
pub fn destroy(_tablet_tool_v2: *TabletToolV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_tool_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
pub const TabletPadV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_pad_v2.interface;pub const ButtonState = common.zwp.tablet_pad_v2.ButtonState;
pub fn setQueue(_tablet_pad_v2: *TabletPadV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {group: struct {pad_group: *client.zwp.TabletPadGroupV2,},
path: struct {path:[*:0]const u8,},
buttons: struct {buttons:u32,},
done: void,button: struct {time:u32,button:u32,state:ButtonState,},
enter: struct {serial:u32,tablet:?*client.zwp.TabletV2,surface:?*client.wl.Surface,},
leave: struct {serial:u32,surface:?*client.wl.Surface,},
removed: void,};
pub inline fn setListener(
    _tablet_pad_v2: *TabletPadV2,
    comptime T: type,
    _listener: *const fn (tablet_pad_v2: *TabletPadV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletPadV2, T).dispatcher, _listener, _mut_data);
}pub fn setFeedback(_tablet_pad_v2: *TabletPadV2, _button:u32, _description:[*:0]const u8, _serial:u32) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_v2);var _args = [_]common.Argument{.{ .u = _button},.{ .s = _description},.{ .u = _serial},};
_proxy.marshal(0, &_args);}
pub fn destroy(_tablet_pad_v2: *TabletPadV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
pub const TabletPadGroupV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_pad_group_v2.interface;pub fn setQueue(_tablet_pad_group_v2: *TabletPadGroupV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_group_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {buttons: struct {buttons:*common.Array,},
ring: struct {ring: *client.zwp.TabletPadRingV2,},
strip: struct {strip: *client.zwp.TabletPadStripV2,},
modes: struct {modes:u32,},
done: void,mode_switch: struct {time:u32,serial:u32,mode:u32,},
};
pub inline fn setListener(
    _tablet_pad_group_v2: *TabletPadGroupV2,
    comptime T: type,
    _listener: *const fn (tablet_pad_group_v2: *TabletPadGroupV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_group_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletPadGroupV2, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_tablet_pad_group_v2: *TabletPadGroupV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_group_v2);_proxy.marshal(0, null);_proxy.destroy();}
};
pub const TabletPadRingV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_pad_ring_v2.interface;pub const Source = common.zwp.tablet_pad_ring_v2.Source;
pub fn setQueue(_tablet_pad_ring_v2: *TabletPadRingV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_ring_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {source: struct {source:Source,},
angle: struct {degrees:common.Fixed,},
stop: void,frame: struct {time:u32,},
};
pub inline fn setListener(
    _tablet_pad_ring_v2: *TabletPadRingV2,
    comptime T: type,
    _listener: *const fn (tablet_pad_ring_v2: *TabletPadRingV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_ring_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletPadRingV2, T).dispatcher, _listener, _mut_data);
}pub fn setFeedback(_tablet_pad_ring_v2: *TabletPadRingV2, _description:[*:0]const u8, _serial:u32) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_ring_v2);var _args = [_]common.Argument{.{ .s = _description},.{ .u = _serial},};
_proxy.marshal(0, &_args);}
pub fn destroy(_tablet_pad_ring_v2: *TabletPadRingV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_ring_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
pub const TabletPadStripV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_pad_strip_v2.interface;pub const Source = common.zwp.tablet_pad_strip_v2.Source;
pub fn setQueue(_tablet_pad_strip_v2: *TabletPadStripV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_strip_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {source: struct {source:Source,},
position: struct {position:u32,},
stop: void,frame: struct {time:u32,},
};
pub inline fn setListener(
    _tablet_pad_strip_v2: *TabletPadStripV2,
    comptime T: type,
    _listener: *const fn (tablet_pad_strip_v2: *TabletPadStripV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_strip_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletPadStripV2, T).dispatcher, _listener, _mut_data);
}pub fn setFeedback(_tablet_pad_strip_v2: *TabletPadStripV2, _description:[*:0]const u8, _serial:u32) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_strip_v2);var _args = [_]common.Argument{.{ .s = _description},.{ .u = _serial},};
_proxy.marshal(0, &_args);}
pub fn destroy(_tablet_pad_strip_v2: *TabletPadStripV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_strip_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
pub const TabletPadDialV2 = opaque {
 pub const generated_version = 1;
 pub const interface = &common.zwp.tablet_pad_dial_v2.interface;pub fn setQueue(_tablet_pad_dial_v2: *TabletPadDialV2, _queue: *client.wl.EventQueue) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_dial_v2);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {delta: struct {value120:i32,},
frame: struct {time:u32,},
};
pub inline fn setListener(
    _tablet_pad_dial_v2: *TabletPadDialV2,
    comptime T: type,
    _listener: *const fn (tablet_pad_dial_v2: *TabletPadDialV2, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_dial_v2);
    const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
    _proxy.addDispatcher(common.Dispatcher(TabletPadDialV2, T).dispatcher, _listener, _mut_data);
}pub fn setFeedback(_tablet_pad_dial_v2: *TabletPadDialV2, _description:[*:0]const u8, _serial:u32) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_dial_v2);var _args = [_]common.Argument{.{ .s = _description},.{ .u = _serial},};
_proxy.marshal(0, &_args);}
pub fn destroy(_tablet_pad_dial_v2: *TabletPadDialV2) void {const _proxy: *client.wl.Proxy = @ptrCast(_tablet_pad_dial_v2);_proxy.marshal(1, null);_proxy.destroy();}
};
